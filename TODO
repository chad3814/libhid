libhid to do list
-----------------

Message-ID: <C1256E2B.00461792.00@gin123.ftgin.com>
Date: Fri, 30 Jan 2004 13:50:07 +0100

Several Notes before beginning:
- CLE is Charles, MKR is Martin and AQU is me,
- I won't be much available next week because of Solutions Linux (Big French/EU
meeting)
and some other critical tasks.
- let's complete the below points, and put it in TODO list.

1) Completion for Get/Set functions

The 3 below facilities are needed, at least c) for all and a/b) for UPSs
support:

  a) dealing with unit conversions:
     Two functions will be provided: hid_convert_logical_to_physical() and
hid_convert_physical_to_logical()
     It's up to the end user app to use it or not.
     => TODO AQU: finish implementation in src/hid_conversion.c

  b) dealing with unit exponent:
     I only see UPSs needing it for the moment, so I wonder if units table and
functions are to be put in libhid.
     => TODO AQU: finish investigation

  c) obtaining the length of reports
     This is already stored in fact, in HIDParser.OffsetTab[ReportID][2]
     To retrieve it, we only need to call "*GetReportOffset(hidif->hid_parser,
hidif->hid_data->ReportID,               hidif->hid_data->Type));" in
hid_get_item_value/hid_set_item_value/... to auto switch to the good values.
     => TODO AQU

2) Usage path / code [reverse] lookup, and wrapping Get/Set[/Event] functions

I've a mecanism in mind, based on a previous development (HiddevBrowser) that
loads only the necessary things (ie when managing an UPS, only load Power Device
Page (x84)
+ Battery System Page (x85) + Vendor Specific Page (based on Vendor ID).
I had no time to continue on this point yet.

Base idea:
- file: hid_usage_lookup.c (still not sure about that name!)
- API:
     HIDUsageTable hid_new_HIDUsageTable();
     hid_return hid_upage_load(HIDUsageTable* const lkptab, int const UPage);
or   hid_return hid_upage_load(HIDUsageTable* const lkptab, char* const UPage);
=> ie "BatterySystem"
     hid_return hid_usage_cleanup(HIDUsageTable* const lkptab);
- a set of file, a bit like usb.ids (UsagePage.hid, BatterySystem.hid, MGE.hid,
...)
- some wrapping function for Get/Set

I'm still not sure about the explicit load...
     => TODO AQU

3) Re integration of HID Parser into libhid core
Following our recent discussion about that, it seems clear that the hidparser
doesn't
need to be extern.
     => TODO MKR? 

4) Interrupt handling (get_input) (aka "dealing with more than the default
endpoints")

To be able to use the interrupt pipe in libusb, we'll need an
entry point in usbdefvs (for linux, don't know for *BSD and Darwin)
that doesn't currently exists! I'm currently looking at how to do it.
My last finding is that libusb 0.1.8 (only in cvs HEAD for the moment)
seems to handle it through generic URB ioctl (for linux). The function
is usb_interrupt_read(...)
I got to test and validate this point
     => TODO AQU

5) Developers and packagers facilities

  - add pkg-config and libhid-config (for platform not supporting the former)
     => I've previously done some pkg-config for NUT ; libhid-config base is
     already present in the old libHID (note that I use the Uppercase to   
     reference it) archive
     => TODO ? [AQU]

  - add hotplug script for dealing with linux usbdevfs priviliges (same as for
SANE)
     => there is already a base in the old libHID archive
     => TODO ? [AQU]                                     

  - Re-integrate doxygen code documentation
     => TODO CLE?                          

6) Various and not planned

  - CVS import on Savannah
  - project update (status, description, ...)
  - dealing with multiple configuration descriptors (if necessary)
  - dealing with physical descriptors (if necessary)


Conclusion:
What I propose is to complete the API, considering the various
need (ie interrupt handling), and to release a 0.1 version that
only deals with control message (so only Get and Set functions,
no Events for the moment.) with 1) and 2) facilities. This will allow us
to complete the base application for phidgets and NUT on
a polled base.

0.2 version will follow quickly, switching to libusb 0.1.8 and
allowing interrupt handling.

0.3 version will then allow multi backend (shut serial layer,
and others depending on the need).

0.4 version might consider a switch to libusb 1.0 API (not
backward compatible with 0.1!)

So the user API of libhid will look like this:
/**********************************************************************************
+************/
void hid_set_debug(HIDDebugLevel const level);
void hid_set_debug_stream(FILE* const outstream);
void hid_set_usb_debug(int const level);

hid_return hid_init();

HIDInterface hid_new_HIDInterface();

void hid_reset_HIDInterface(HIDInterface* const hidif);

hid_return hid_cleanup();

bool hid_is_initialised();

hid_return hid_open(HIDInterface* const hidif, int const interface,
    HIDInterfaceMatcher const* const match);

hid_return hid_force_open(HIDInterface* const hidif, int const interface,
    HIDInterfaceMatcher const* const match, unsigned short retries);     

hid_return hid_close(HIDInterface* const hidif);

bool hid_is_opened(HIDInterface const* const hidif);

hid_return hid_get_item_value(HIDInterface* const hidif,
                              int const path[], unsigned int const depth,
                              double *const value);
=> work with control transfer

hid_return hid_set_item_value(HIDInterface* const hidif,
                              int const path[], unsigned int const depth,
                              double const value);
=> work with control transfer, or output if available (need to be validated)

hid_return hid_get_item_string(HIDInterface* const hidif,

hid_return hid_get_item_string(HIDInterface* const hidif,
                               int const path[], unsigned int const depth,
                               char *const value, unsigned int const maxlen);
=> I'm still not sure about the need of that one!

hid_return hid_get_event_value(HIDInterface* const hidif,
                              int path[], unsigned int depth,
                              double *const value);
=> work with interrupt transfer, return the path and the value of the device
generated event.

hid_return hid_write_identification(FILE* const out,
    HIDInterface const* const hidif);

hid_return hid_dump_tree(FILE* const out, HIDInterface* const hidif);

/**********************************************************************************
+************/

Note that:
1) I've discarded the following as these are not useful:
- hid_return hid_get_input_report(HIDInterface* const hidif, int const path[],
    unsigned int const depth, char* const buffer, unsigned int const size);   
- hid_return hid_set_output_report(HIDInterface* const hidif, int const path[],
    unsigned int const depth, char const* const buffer, unsigned int const     
size);
2) The above API is designed to be simple, so it use the control endpoint
for the Get/Set ops, and the interrupt endpoint for Get_Event.
