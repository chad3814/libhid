#!/usr/bin/env python

"""This module is mostly a playground for descriptor-parsing code.

Copyright (c) 2005 Charles Lepple

You may distribute this file under the terms of either the GNU General Public
License or the Artistic License."""

__author__ = "Charles Lepple <clepple+libhid@ghz.cc>"
__date__   = "20 February 2005"

import os, sys, re

def extract_bytes(f):
   """Extract an array of bytes from a hex dump generated by libhid.
   The returned list contains unsigned integers corresponding to the
   bytes."""
   descriptor_seen = 0
   descriptor_text = []

   for line in f:
       if descriptor_seen:
           if 'parsing the HID tree' in line:
               descriptor_seen = 0
           else:
               # Chop off "TRACE: hid_prepare_parser(): 0xZZZ":
	       descriptor_text += line.split()[3:]
       else:
           if 'raw report descriptor' in line:
               descriptor_seen = 1

   # Map each string element into an integer:
   return [int(var, 16) for var in descriptor_text]

def extract_bytes_from_asm(f):
   """Extract an array of descriptor bytes from an assembly file.
   The returned list contains unsigned integers corresponding to the
   bytes."""
   descriptor_text = []

   re_ret = re.compile(r'ret[a-z]+', re.IGNORECASE)
   # Labels begin in the first column, and optionally have a colon afterwards:
   re_label = re.compile(r'^[a-z0-9_]+:?', re.IGNORECASE)
   re_comment = re.compile(r';.*$')

   for line in f:
       line = re_comment.sub('', line)
       line = re_label.sub('', line)
       line = re_ret.sub('', line)
       # print "Line: " + line
       descriptor_text += line.split()

   # Map each string element into an integer:
   return [int(var, 16) for var in descriptor_text]
# string.join([ "%02x" % var for var in descriptor_bytes])

def parse_tag(desc, index = 0):
    """Examine and print information about the item at desc[index].

    Returns the length of the item (including the tag), which can be used to
    advance index to the next item in the descriptor.

    Currently, only short tags are handled.

    bSize:
    0 = 0 bytes
    1 = 1 byte
    2 = 2 bytes
    3 = 4 bytes"""

    bSize = (1 << (desc[index] & 0x3)) / 2
    bType = (desc[index] >> 2) & 0x3
    bTag  = (desc[index] >> 4) & 0xF
    print "[0x%04x]" % index,
    for byte in range(bSize+1):
        print "0x%02x" % desc[index+byte],
    print
    print "  bSize = %d byte(s)" % bSize
    print "  bType = 0x%02x (%s)" % (bType, ('Main', 'Global', 'Local', 'Reserved')[bType])
    print "  bTag  = 0x%02x" % bTag
    return bSize + 1

def tokenize_descriptor(desc):
    byte_index = 0;
    while byte_index < len(desc):
        byte_index += parse_tag(desc, byte_index)

def main():
    if(len(sys.argv) > 1):
        fname = sys.argv[1]
    else:
        fname = '../ref/test_libhid_output/Apple_17_inch_Studio_Display'

    f = open(fname, 'r')
    desc_bytes = extract_bytes(f)
    f.close()

    tokenize_descriptor(desc_bytes)

    print "done"

if __name__ == '__main__':
    main()
